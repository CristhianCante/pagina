<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Módulo: Clustering con K-Means - Guía de PostGIS Bogotá</title>
    <!-- Tailwind CSS para un diseño rápido y responsivo -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Estilos para el contenido del artículo */
        .article-content h2 {
            font-size: 1.875rem; /* text-3xl */
            font-weight: 800; /* extrabold */
            color: #1f2937; /* gray-800 */
            margin-top: 2.5rem; /* mt-10 */
            margin-bottom: 1rem; /* mb-4 */
            border-bottom: 2px solid #e5e7eb; /* border-gray-200 */
            padding-bottom: 0.5rem; /* pb-2 */
        }
        .article-content h3 {
            font-size: 1.5rem; /* text-2xl */
            font-weight: 700; /* bold */
            color: #1f2937; /* gray-800 */
            margin-top: 2rem; /* mt-8 */
            margin-bottom: 1rem; /* mb-4 */
        }
        .article-content p, .article-content ul, .article-content ol {
            font-size: 1.125rem; /* text-lg */
            color: #374151; /* gray-700 */
            line-height: 1.75;
            margin-bottom: 1rem;
        }
        .article-content ul {
            list-style-type: disc;
            padding-left: 2rem;
        }
        .article-content a {
            color: #2563eb; /* blue-600 */
            text-decoration: none;
            transition: color 0.2s;
        }
        .article-content a:hover {
            color: #1d4ed8; /* blue-800 */
            text-decoration: underline;
        }
        .article-content code:not(.hljs) { /* Código inline */
            background-color: #e5e7eb;
            padding: 0.125rem 0.375rem;
            border-radius: 0.25rem;
            font-family: monospace;
            font-size: 0.9em;
        }
        .code-block-container {
            position: relative;
            margin-top: 1.5rem;
            margin-bottom: 1.5rem;
        }
        .copy-button {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            background-color: #4b5563;
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            cursor: pointer;
            transition: background-color 0.2s;
            border: 1px solid #6b7280;
        }
        .copy-button:hover {
            background-color: #374151;
        }
        .copy-button.copied {
            background-color: #16a34a; /* green-600 */
        }
        .styled-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            margin-bottom: 1.5rem;
            font-size: 0.9rem;
        }
        .styled-table th, .styled-table td {
            border: 1px solid #d1d5db;
            padding: 0.75rem;
            text-align: left;
        }
        .styled-table th {
            background-color: #f3f4f6;
            font-weight: 600;
        }
        .styled-table tbody tr:nth-child(odd) {
            background-color: #f9fafb;
        }
    </style>
    <!-- Highlight.js para el resaltado de sintaxis SQL -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/sql.min.js"></script>
</head>
<body class="bg-gray-50 text-gray-800">

    <div class="container mx-auto px-4 sm:px-6 lg:px-8 py-10">

        <!-- ===== NAVEGACIÓN DE VUELTA ===== -->
        <nav class="mb-6">
            <a href="index.html" class="text-blue-600 hover:text-blue-800 hover:underline transition-colors duration-200 text-lg">
                &larr; Volver a la página principal de la guía
            </a>
        </nav>

        <!-- ===== CABECERA DEL MÓDULO ===== -->
        <header class="mb-12">
            <h1 class="text-4xl md:text-5xl font-extrabold text-gray-900 mb-2">
                Clustering con K-Means y otras funciones de Agrupamiento
            </h1>
            <p class="text-xl text-gray-600">
                Identificando grupos y patrones en datos espaciales con PostGIS.
            </p>
        </header>

        <article class="bg-white p-6 sm:p-8 lg:p-12 rounded-xl shadow-md border border-gray-200 article-content">
            
            <h2>1. ¿Qué es el Clustering Espacial?</h2>
            <p>
                El <strong>clustering</strong> o <strong>agrupamiento</strong> es un algoritmo de aprendizaje no supervisado que permite agrupar datos según su similitud. En el contexto de las bases de datos espaciales, el clustering nos permite agrupar geometrías (como puntos de incidentes o polígonos de edificios) basándonos en su proximidad espacial.
            </p>
            <p>
                Es una herramienta fundamental para identificar "puntos calientes", segmentar áreas con características similares, detectar patrones y analizar la distribución de fenómenos en el territorio.
            </p>

            <h2>2. Funciones de Clustering en PostGIS</h2>
            <p>PostGIS ofrece varias funciones de ventana (window functions) para realizar clustering directamente en la base de datos.</p>

            <h3>2.1. `ST_ClusterDBSCAN`</h3>
            <p>
                Esta función agrupa geometrías utilizando el algoritmo <strong>DBSCAN</strong>, que se basa en la densidad. Asigna geometrías al mismo clúster si están "densamente conectadas". Requiere dos parámetros:
            </p>
            <ul>
                <li><code>eps</code>: La distancia máxima para considerar que dos puntos son vecinos.</li>
                <li><code>min_points</code>: El número mínimo de puntos necesarios para formar una región densa (un clúster).</li>
            </ul>
            <p>Una de sus ventajas es que no requiere que especifiquemos el número de clústeres de antemano y puede identificar puntos atípicos (ruido) como <code>NULL</code>.</p>
            <p><strong>Ejemplo:</strong> Agrupar los incidentes de la localidad de Fontibón que estén a una distancia máxima de 3.5 metros y formen grupos de al menos 10 puntos.</p>
            <div class="code-block-container">
                <button class="copy-button">Copiar</button>
                <pre><code class="language-sql">SELECT
    ST_ClusterDBSCAN(geom, eps := 0.0035, minpoints := 10) OVER() AS cluster_id,
    geom
FROM incidentes_final;</code></pre>
            </div>
            <p>Para contar cuántos puntos hay en cada clúster generado:</p>
            <div class="code-block-container">
                <button class="copy-button">Copiar</button>
                <pre><code class="language-sql">SELECT
    cluster_id,
    COUNT(*) AS num_puntos
FROM (
    SELECT ST_ClusterDBSCAN(geom, eps := 0.0035, minpoints := 10) OVER() AS cluster_id
    FROM incidentes_final
) AS subquery
GROUP BY cluster_id
ORDER BY cluster_id;</code></pre>
            </div>

            <h3>2.2. `ST_ClusterKMeans`</h3>
            <p>
                Esta función implementa el popular algoritmo <strong>K-Means</strong>, que particiona las geometrías en un número <strong>K</strong> de clústeres predefinido. El algoritmo asigna cada geometría al clúster cuyo centroide esté más cerca.
            </p>
            <p><strong>Ejemplo:</strong> Dividir todos los incidentes de Fontibón en 3 grandes grupos o clústeres.</p>
            <div class="code-block-container">
                <button class="copy-button">Copiar</button>
                <pre><code class="language-sql">SELECT 
    ST_ClusterKMeans(geom, 3) OVER() AS cluster_id, 
    id, 
    geom
FROM incidentes_final;</code></pre>
            </div>
             <p>Para contar los puntos en cada uno de los 3 clústeres:</p>
            <div class="code-block-container">
                <button class="copy-button">Copiar</button>
                <pre><code class="language-sql">SELECT
    cluster_id,
    COUNT(*) AS num_puntos
FROM (
    SELECT ST_ClusterKMeans(geom, 3) OVER() AS cluster_id
    FROM incidentes_final
) AS subquery
GROUP BY cluster_id
ORDER BY cluster_id;</code></pre>
            </div>

            <h3>2.3. `ST_ClusterIntersectingWin` y `ST_ClusterWithinWin`</h3>
            <p>Estas funciones agrupan geometrías basándose en relaciones espaciales directas:</p>
            <ul>
                <li><strong><code>ST_ClusterIntersectingWin</code>:</strong> Asigna el mismo ID de clúster a todas las geometrías que se intersectan entre sí, formando un componente conectado.</li>
                <li><strong><code>ST_ClusterWithinWin</code>:</strong> Asigna el mismo ID de clúster a las geometrías que están a una distancia determinada unas de otras.</li>
            </ul>
            <p><strong>Ejemplo con `ST_ClusterIntersectingWin`:</strong> Agrupar las vías de Fontibón que están conectadas.</p>
            <div class="code-block-container">
                <button class="copy-button">Copiar</button>
                <pre><code class="language-sql">SELECT 
    ST_ClusterIntersectingWin(geom) OVER () AS cluster_id,
    geom
FROM mallavial_f;</code></pre>
            </div>
            <p><strong>Ejemplo con `ST_ClusterWithinWin`:</strong> Agrupar incidentes que estén a una distancia máxima de 3 metros entre sí.</p>
            <div class="code-block-container">
                <button class="copy-button">Copiar</button>
                <pre><code class="language-sql">SELECT 
    ST_ClusterWithinWin(geom, 0.003) OVER () AS cluster_id, 
    id, 
    geom
FROM incidentes_final;</code></pre>
            </div>

            <h2>5. Recomendaciones</h2>
            <ul>
                <li>Para agrupar <strong>puntos</strong>, se recomienda usar <code>ST_ClusterKMeans</code> (si conoces el número de grupos deseado) o <code>ST_ClusterDBSCAN</code> (si quieres descubrir agrupaciones basadas en densidad).</li>
                <li>Para agrupar <strong>líneas o polígonos</strong> que se tocan, <code>ST_ClusterIntersectingWin</code> es la función ideal.</li>
                <li>Recuerda que para contar el número total de geometrías por clúster, usas <code>COUNT(*)</code>. Si quieres saber cuántas geometrías <em>únicas</em> hay (en caso de duplicados), usas <code>COUNT(DISTINCT geom)</code>.</li>
            </ul>

        </article>
        
        <!-- ===== PIE DE PÁGINA ===== -->
        <footer class="text-center mt-16 pt-8 border-t border-gray-300">
            <p class="text-gray-600">&copy; 2025 Universidad Distrital Francisco José de Caldas. Todos los derechos reservados.</p>
            <p class="text-sm text-gray-500 mt-1">Este material se distribuye bajo la licencia Creative Commons Atribución-CompartirIgual.</p>
        </footer>
    </div>
    <script>
        // Inicializa Highlight.js para resaltar todos los bloques de código
        hljs.highlightAll();

        // Agrega la funcionalidad de copiado a todos los botones
        const copyButtons = document.querySelectorAll('.copy-button');
        copyButtons.forEach(button => {
            button.addEventListener('click', () => {
                const pre = button.parentElement.querySelector('pre > code');
                const textToCopy = pre.innerText;

                // Usamos un textarea temporal para copiar el texto
                const textArea = document.createElement('textarea');
                textArea.value = textToCopy;
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    button.innerText = 'Copiado!';
                    button.classList.add('copied');
                } catch (err) {
                    console.error('Error al copiar el texto: ', err);
                    button.innerText = 'Error';
                }
                document.body.removeChild(textArea);

                // Revertir el texto del botón después de 2 segundos
                setTimeout(() => {
                    button.innerText = 'Copiar';
                    button.classList.remove('copied');
                }, 2000);
            });
        });
    </script>
</body>
</html>
